
---

## 🚀 1단계 - 로또 자동 구매

---

## 📝 요구사항

- 로또 구입 금액을 입력하면 구입 금액에 해당하는 로또를 발급해야 한다.
- 로또 1장의 가격은 1000원이다.



## 💻 구현 과정

1. 프로그레밍 요구사항에 맞는 domain 작성(mvc 패턴 도입)
2. domain의 구조 변경, LottoGenerator 로 도메인의 역할을 분리
3. `view` 작성
4. `controller` 작성
5. `controller`에서 `servive` 추출
6. Main 컴포넌트 작동하게끔 수정

## 🤔 고민한 부분들


### ▶️ `Lotto` 도메인을 "빈약한 도메인"으로 만들지 않기

저번 리뷰에서, 도메인의 역할에 대한 리뷰 중 "빈약한 도메인 모델"과 "부유한 도메인 모델"에 관해 학습했습니다!
빈약한 도메인 모델이란 도메인 객체들에 비즈니스 로직이 거의 없거나 아예 누락되어있는 모델로써,
규모가 커졌을 때 객체지향에 있어서는 **안티패턴** 이라고 학습했습니다!
그러나 테스트나 유지보수에 있어서는 controller와 domain에서 로직의 분리가 이루어져야 하기 때문에
`Lotto`도메인에 "검증 로직"을 추가하여 빈약하지 않지만, generator와 domain에서 로직을 다룰 수 있게 되었고,
domain은 데이터를 검증하고 저장하는 역할을 하게 되었습니다.


---

## 🚀 2단계 - 로또 당첨

---

- 로또 당첨 번호를 받아 일치한 번호 수에 따라 당첨 결과를 보여준다.

## ➕ 새로운 프로그래밍 요구사항

- 모든 원시 값과 문자열을 포장한다.
- 일급 컬렉션을 쓴다.

## 💻 구현 과정

1. LottoService로 로또일치를 판별할 룰을 설정
2. 테스트코드 작성

## 🤔 고민한 부분들



## 😂 실수한 부분

이번 주는 시간이 정말 안나서, 목요일날 급한 마음으로 미션을 진행하느라 테스트코드보다 본 코드를 먼저 작성했습니다.
물론 본 코드를 먼저 작성할 때의 장점이 분명히 있다고 생각합니다만,(코드의 자동완성, 작성속도 향상 등)
저는 안정성 높은 좋은 코드를 위해서는 테스트코드를 먼저 작성한 후에 개발을 진행해야 한다고 생각합니다.
테스트코드를 마지막에 작성한건 온전히 저의 실수입니다.😢


## 🚀 3단계 - 로또 자동 구현



---

## 📝 요구사항

- 2등을 위한 보너스볼을 추첨한다.
- 당첨 통계에 2등을 추가한다.
    - 2등 당첨 조건은 당첨 번호 5개 일치 + 보너스 볼 일치다.


## ➕ 새로운 프로그래밍 요구사항

- Java Enum을 적용한다.



## 💻 구현 과정

1. 프로그레밍 요구사항에 맞는 `view` 우선 작성
2. Lotto에 bonusNumber와의 대조를 하는 로직을 추가
3. enum에 새로운 열거 상수 추가 ('BONUSFIVE'), `MatchReward` 매칭 로직 개선
4. `controller` 수정

## 🤔 고민한 부분들


### ▶️ `enum`에서, 보너스넘버에 따른 매칭을 비교하는 위치
처음에 코드를 작성할 때, 저는 보너스넘버가 기존 넘버가 일치할 때를 boolean으로 관리하기 위해 `enum`에 새로운 `boolean` 필드를 추가했습니다!
```java

    MatchReward(int matchCount, int prize, boolean isBonusMatched) {
        this.matchCount = matchCount;
        this.prize = prize;
        this.isBonusMatched = isBonusMatched;
    }

```

위와 같이 작성하여, 열거 상수에서 `BONUSFIVE`만을 `true`로 두고, 나머지는 `false`로 두어
`matchCount`가 5 이고 `isBonusMatched`가 true 일때 `BONUSFIVE`를 리턴하는 형식으로 관리할 생각이었습니다만,
하나의 열거 상수에서만 사용될 boolean을 위해 불필요한 필드를 만드는 것은 다른 enum 열거 상수들의 통일성을 해친다고 생각이 들었고, 지금과 같이 `of` 정적 팩토리 매서드에서 비교를 하는 방식으로 수정하였습니다!




---

## 🚀 4단계 - 로또 수동 구매

---

## 📝 요구사항

- 현재 로또 생성기는 자동 생성 기능만 제공한다. 사용자가 수동으로 추첨 번호를 입력할 수 있도록 해야 한다.
- 입력한 금액, 자동 생성 숫자, 수동 생성 번호를 입력하도록 해야 한다.


## 💻 구현 과정

1. 프로그레밍 요구사항에 맞는 `view` 우선 작성
2. 수동으로 받은 번호로 티켓을 만드는 `ManualLottoGenerator` 도메인 로직 추가
3. 요구사항에 부합하게끔 컨트롤러 리팩토링


## 🚀 5단계 - 리팩터링

## ➕ 새로운 프로그래밍 요구사항

- 기존 프로그래밍 요구사항을 다시 한번 확인하고, 학습 테스트를 통해 학습한 내용을 반영한다.

## 💻 구현 과정 (controller 리팩터링에 집중)

1.  `controller` 에서 `ManualLottoTicketsGenerator`의 책임 분리
2. `controller` 에서 오케스트레이션 메서드의 책임 분리
3. `controller` 에서 view 연속 출력 메서드 분리

## 🤔 고민한 부분들


### ▶️ 입력받은 값의 오류를 검증하는 위치

첫 제출시에 질문사항이었던 부분입니다.
코드를 작성하면서 입력받은 값을 검증하는 로직의 위치를 어디로 하면 좋을지 고민했습니다.
아예 다른 자료형이 들어오는 경우에는 `view`에서 검증로직을 둘 수 있겠지만,
사용자로부터 받은 객체가 아닌 값들의 검증로직은 `controller`에서 해결할 수밖에 없었습니다.
(현재 제 코드는 사용자로부터 받은 값이 유효하지 않으면 다시 값을 입력할 수 있도록 기회를 주고 있습니다.
그렇기 때문에 기존 방식으로는 `controller`에서 검증과 반복을 한 흐름에서 처리해야 했습니다.)

그러나 질문을 작성하던 중, "검증 로직은 객체 스스로에게 있어야 자연스럽다"는 생각이 떠올랐습니다.
그래서 `domain`에 사용자에게 받은 입력을 저장하고, 검증하는 독립적인 `record` 값 객체를 만들어, 모든 검증 로직을 객체 스스로가 처리하도록 리팩토링을 진행하였습니다.
